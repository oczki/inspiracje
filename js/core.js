const iconArrowLeft = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>';
const iconArrowRight = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z" /></svg>';

const iconCog = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z" /></svg>';
const iconInfo = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></svg>';
const iconAutoRenew = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M12,6V9L16,5L12,1V4A8,8 0 0,0 4,12C4,13.57 4.46,15.03 5.24,16.26L6.7,14.8C6.25,13.97 6,13 6,12A6,6 0 0,1 12,6M18.76,7.74L17.3,9.2C17.74,10.04 18,11 18,12A6,6 0 0,1 12,18V15L8,19L12,23V20A8,8 0 0,0 20,12C20,10.43 19.54,8.97 18.76,7.74Z" /></svg>';
const iconClose = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" /></svg>';

const iconCheckboxBlankOutline = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z" /></svg>';
const iconCheckboxMarked = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z" /></svg>';
const iconFormatSize = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M2 4V7H7V19H10V7H15V4H2M21 9H12V12H15V19H18V12H21V9Z" /></svg>';
const iconPlusBox = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M17,13H13V17H11V13H7V11H11V7H13V11H17M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z" /></svg>';
const iconMinusBox = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M17,13H7V11H17M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z" /></svg>';
const iconPlusBoxOutline = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19,19V5H5V19H19M19,3A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5C3,3.89 3.9,3 5,3H19M11,7H13V11H17V13H13V17H11V13H7V11H11V7Z" /></svg>';
const iconMinusBoxOutline = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19,19V5H5V19H19M19,3A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5C3,3.89 3.9,3 5,3H19M17,11V13H7V11H17Z" /></svg>';

const iconEmail = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z" /></svg>';
const iconGithub = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z" /></svg>';
const iconCopyright = '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M10.08,10.86C10.13,10.53 10.24,10.24 10.38,10C10.5,9.74 10.72,9.53 10.97,9.37C11.21,9.22 11.5,9.15 11.88,9.14C12.11,9.15 12.32,9.19 12.5,9.27C12.71,9.36 12.89,9.5 13.03,9.63C13.17,9.78 13.28,9.96 13.37,10.16C13.46,10.36 13.5,10.58 13.5,10.8H15.3C15.28,10.33 15.19,9.9 15,9.5C14.85,9.12 14.62,8.78 14.32,8.5C14,8.22 13.66,8 13.24,7.84C12.82,7.68 12.36,7.61 11.85,7.61C11.2,7.61 10.63,7.72 10.15,7.95C9.67,8.18 9.27,8.5 8.95,8.87C8.63,9.26 8.39,9.71 8.24,10.23C8.09,10.75 8,11.29 8,11.87V12.14C8,12.72 8.08,13.26 8.23,13.78C8.38,14.3 8.62,14.75 8.94,15.13C9.26,15.5 9.66,15.82 10.14,16.04C10.62,16.26 11.19,16.38 11.84,16.38C12.31,16.38 12.75,16.3 13.16,16.15C13.57,16 13.93,15.79 14.24,15.5C14.55,15.25 14.8,14.94 15,14.58C15.16,14.22 15.27,13.84 15.28,13.43H13.5C13.5,13.64 13.43,13.83 13.34,14C13.25,14.19 13.13,14.34 13,14.47C12.83,14.6 12.66,14.7 12.46,14.77C12.27,14.84 12.07,14.86 11.86,14.87C11.5,14.86 11.2,14.79 10.97,14.64C10.72,14.5 10.5,14.27 10.38,14C10.24,13.77 10.13,13.47 10.08,13.14C10.03,12.81 10,12.47 10,12.14V11.87C10,11.5 10.03,11.19 10.08,10.86M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20Z" /></svg>';

let containers = [
  {
    type: "location",
    label: "Miejsce",
    color: {
      hue: 75,
      lightMode: {
        saturation: {
          card: 65,
          header: 100,
          word: 84,
          icon: 84,
        },
        lightness: {
          card: 95,
          header: 24,
          word: 23,
          icon: 23,
        },
      },
      darkMode: {
        saturation: {
          card: 35,
          header: 85,
          word: 60,
          icon: 60,
        },
        lightness: {
          card: 10,
          header: 29,
          word: 54,
          icon: 54,
        },
      },
    },
    prevButtonPrefix: "Poprzednie",
    nextButtonPrefix: "Następne",
  },
  {
    type: "character",
    label: "Postać",
    color: {
      hue: 55,
      lightMode: {
        saturation: {
          card: 65,
          header: 100,
          word: 100,
          icon: 100,
        },
        lightness: {
          card: 95,
          header: 24,
          word: 22,
          icon: 22,
        },
      },
      darkMode: {
        saturation: {
          card: 31,
          header: 100,
          word: 64,
          icon: 64,
        },
        lightness: {
          card: 10,
          header: 30,
          word: 56,
          icon: 56,
        },
      },
    },
  },
  {
    type: "character-modifier",
    label: "Cecha postaci",
    color: {
      hue: 30,
      lightMode: {
        saturation: {
          card: 65,
          header: 100,
          word: 100,
          icon: 100,
        },
        lightness: {
          card: 95,
          header: 31,
          word: 30,
          icon: 30,
        },
      },
      darkMode: {
        saturation: {
          card: 32,
          header: 55,
          word: 92,
          icon: 92,
        },
        lightness: {
          card: 11,
          header: 45,
          word: 69,
          icon: 69,
        },
      },
    },
  },
  {
    type: "emotion",
    label: "Emocja",
    color: {
      hue: 0,
      lightMode: {
        saturation: {
          card: 65,
          header: 83,
          word: 68,
          icon: 68,
        },
        lightness: {
          card: 96,
          header: 37,
          word: 40,
          icon: 40,
        },
      },
      darkMode: {
        saturation: {
          card: 24,
          header: 40,
          word: 100,
          icon: 100,
        },
        lightness: {
          card: 12.5,
          header: 56,
          word: 80,
          icon: 80,
        },
      },
    },
  },
  {
    type: "relation",
    label: "Relacja",
    color: {
      hue: 325,
      lightMode: {
        saturation: {
          card: 70,
          header: 96,
          word: 67,
          icon: 67,
        },
        lightness: {
          card: 95.5,
          header: 34,
          word: 39,
          icon: 39,
        },
      },
      darkMode: {
        saturation: {
          card: 26,
          header: 45,
          word: 89,
          icon: 89,
        },
        lightness: {
          card: 12,
          header: 55,
          word: 78,
          icon: 78,
        },
      },
    },
  },
  {
    type: "action",
    label: "Czynność",
    color: {
      hue: 295,
      lightMode: {
        saturation: {
          card: 65,
          header: 88,
          word: 60,
          icon: 60,
        },
        lightness: {
          card: 95,
          header: 36,
          word: 38,
          icon: 38,
        },
      },
      darkMode: {
        saturation: {
          card: 28,
          header: 37,
          word: 75,
          icon: 75,
        },
        lightness: {
          card: 12,
          header: 54,
          word: 77,
          icon: 77,
        },
      },
    },
  },
  // {
  //   type: "body-part",
  //   label: "Część ciała",
  // },
  // {
  //   type: "genre",
  //   label: "Gatunek filmowy",
  //   prevButtonPrefix: "Poprzedni",
  //   nextButtonPrefix: "Następny",
  // },
  // {
  //   type: "name",
  //   label: "Imię",
  //   prevButtonPrefix: "Poprzednie",
  //   nextButtonPrefix: "Następne",
  // },
  // {
  //   type: "noun",
  //   label: "Rzeczownik",
  //   prevButtonPrefix: "Poprzedni",
  //   nextButtonPrefix: "Następny",
  // },
  // {
  //   type: "dictionary",
  //   label: "Dowolne słowo",
  //   prevButtonPrefix: "Poprzednie",
  //   nextButtonPrefix: "Następne",
  // },
];

let wordsContainer = [];

const fontScaleValues = [0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.35, 1.5];
const visibleClass = 'visible';
const defaulSwiperAnimationDuration = 180;
const defaultSheetClosingAnimationDuration = 200;
const defaultDelayBetweenLoadedWordsDuration = 20;
const defaultFabTransitionDuration = 280;
const defaultIconRotationDuration = 500;
const defaultSpinnerOverlayFadeDuration = 120;

let swiperAnimationDuration = defaulSwiperAnimationDuration;
let sheetClosingAnimationDuration = defaultSheetClosingAnimationDuration;
let delayBetweenLoadedWordsDuration = defaultDelayBetweenLoadedWordsDuration;
let fabTransitionDuration = defaultFabTransitionDuration;
let iconRotationDuration = defaultIconRotationDuration;
let spinnerOverlayFadeDuration = defaultSpinnerOverlayFadeDuration;

let isDarkModeEnabled = false;

let Selector = new function() {
  this.sectionId = (type) => {
    return `section-${type}`;
  }

  this.swiperSelector = (type) => {
    return `#${this.sectionId(type)} .swiper-container`;
  }

  this.getSwiper = (type) => {
    return document.querySelector(this.swiperSelector(type))?.swiper;
  }

  this.getScrim = () => {
    return document.getElementById('scrim');
  }
}

let Util = new function() {
  this.shuffle = (arr) => {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  this.ajax = (url, callback) => {
    let xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4 && xhr.status == 200) {
        callback(xhr.responseText);
      }
    }
    xhr.open('GET', url, true);
    xhr.send();
  }

  this.getWords = (type, callback) => {
    this.ajax('ajax/' + type + '.php', (output) => callback(output));
  }

  this.roundTransformationProperties = (element) => {
    const elementStyle = window.getComputedStyle(element);
    let matrix;
    if (typeof DOMMatrix !== 'undefined') {
      matrix = new DOMMatrix(elementStyle.transform);
    } else if (typeof CSSMatrix !== 'undefined') {
      matrix = new CSSMatrix(elementStyle.transform);
    } else if (typeof MSCSSMatrix !== 'undefined') {
      matrix = new MSCSSMatrix(elementStyle.transform);
    } else if (typeof WebKitCSSMatrix !== 'undefined') {
      matrix = new WebKitCSSMatrix(elementStyle.webkitTransform);
    }

    const translateX = matrix.m41;
    if (translateX % 2) {
      element.style.setProperty('--translateX', `${translateX.toFixed(0)}px`);
    }
    const translateY = matrix.m42;
    if (translateY % 2) {
      element.style.setProperty('--translateY', `${translateY.toFixed(0)}px`);
    }
  }

  this.clearTransformationProperties = (element) => {
    element.style.removeProperty('--translateX');
    element.style.removeProperty('--translateY');
  }

  this.debounce = (callback, timeout, immediate = false) => {
    let timer;
    return function() {
      let context = this, args = arguments;
      let later = function() {
        timer = null;
        if (!immediate) callback.apply(context, args);
      };
      var callNow = immediate && !timer;
      clearTimeout(timer);
      timer = setTimeout(later, timeout);
      if (callNow) callback.apply(context, args);
    };
  }

  this.throttle = (callback, timeout) => {
    let timer;
    let blocked = false;
    return function() {
      if (blocked) return;
      blocked = true;
      callback.apply(this, arguments)
      clearTimeout(timer);
      timer = setTimeout(() => blocked = false, timeout);
    }
  }
}

class Color {
  constructor(hue = 0, saturation = 0, lightness = 0) {
    // If the passed lone argument was a string, parse it as hexadecimal color
    if (typeof(hue) === 'string' && arguments.length === 1) {
      const rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hue);
      const r = parseInt(rgb[1], 16);
      const g = parseInt(rgb[2], 16);
      const b = parseInt(rgb[3], 16);
      [this.h, this.s, this.l] = this.rgb2hsl(r, g, b);
    } else { // Otherwise treat the arguments as hue, saturation, lightness
      this.h = hue;
      this.s = saturation;
      this.l = lightness;
    }
  }

  // RGB <-> HSL code based on https://stackoverflow.com/a/9493060/5024905
  rgb2hsl(r, g, b) {
    r /= 255, g /= 255, b /= 255;
    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      let d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return [h * 360, s * 100, l * 100];
  }

  get hsl() {
    return [this.h, this.s, this.l];
  }

  get hslString() {
    return `hsl(${this.h}deg, ${this.s}%, ${this.l}%)`;
  }

  hslaString(alpha = 1.0) {
    return `hsla(${this.h}deg, ${this.s}%, ${this.l}%, ${alpha})`;
  }

  get rgb() {
    let h = this.h / 360;
    let s = this.s * 0.01;
    let l = this.l * 0.01;
    let r, g, b;
    if (s == 0) {
      r = g = b = l;
    } else {
      let hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      }

      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  }

  get hex() {
    const [r, g, b] = this.rgb;
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }
}

class ColorSetter {
  constructor(containerData) {
    this.colorData = isDarkModeEnabled ? containerData?.color?.darkMode : containerData?.color?.lightMode;
    this.hue = containerData?.color?.hue || 0;
    this.sectionElement = document.getElementById(Selector.sectionId(containerData.type));
  }

  setColors() {
    if (!this.sectionElement) return;
    this.setSectionBackground();
    this.setSectionShadow();
    this.setHeaderTextColor();
    this.setWordTextColor();
    this.setNavigationButtonsColor();
    this.setOverlayDotColor();
  }

  setSectionBackground() {
    const s = this.colorData?.saturation?.card || 0;
    const l = this.colorData?.lightness?.card || 0;
    const color = new Color(this.hue, s, l);
    this.sectionElement.style.backgroundColor = color?.hslString;
  }

  setSectionShadow() {
    const shadowPropertyName = '--card-shadow-override';
    if (isDarkModeEnabled) {
      this.sectionElement.style.removeProperty(shadowPropertyName);
      return;
    }
    const s = this.colorData?.saturation?.word || 0;
    const l = this.colorData?.lightness?.word || 0;
    const color = new Color(this.hue, s, l);
    const shadowDefinition = `0px 2px 1px -1px ${color?.hslaString(0.2)},
      0px 1px 2px 0px ${color?.hslaString(0.14)},
      0px 1px 3px 0px ${color?.hslaString(0.12)}`;
    this.sectionElement.style.setProperty(shadowPropertyName, shadowDefinition);
  }

  setHeaderTextColor() {
    const header = this.sectionElement.querySelector('.header-container');
    if (!header) return;

    const s = this.colorData?.saturation?.header;
    const l = this.colorData?.lightness?.header;
    const color = new Color(this.hue, s, l);
    header.style.color = color?.hslString;
  }

  setWordTextColor() {
    const wordWrapper = this.sectionElement.querySelector('.swiper-wrapper');
    if (!wordWrapper) return;

    const s = this.colorData?.saturation?.word;
    const l = this.colorData?.lightness?.word;
    const color = new Color(this.hue, s, l);
    wordWrapper.style.color = color?.hslString;
  }

  setNavigationButtonsColor() {
    const navigationButtons = this.sectionElement.querySelectorAll('button');
    if (!navigationButtons) return;

    const s = this.colorData?.saturation?.icon;
    const l = this.colorData?.lightness?.icon;
    const color = new Color(this.hue, s, l);
    Array.from(navigationButtons).forEach(button => button.style.color = color?.hslString);
  }

  setOverlayDotColor() {
    const dotColorPropertyName = '--dot-color';
    const overlay = this.sectionElement.querySelector('.section-overlay');
    if (!overlay) return;

    const s = this.colorData?.saturation?.word;
    const l = this.colorData?.lightness?.word;
    const color = new Color(this.hue, s, l);
    overlay.style.setProperty(dotColorPropertyName, color.hslString);
  }
}

let ColorUtil = new function() {
  this.mixColors = (color1, color2, factor = 0.5) => {
    let lerp = (val1, val2) => {
      const result = (1 - factor) * val1 + factor * val2;
      return Math.round(result);
    }

    if (!(color1 instanceof Color))
      color1 = new Color(color1);
    if (!(color2 instanceof Color))
      color2 = new Color(color2);

    let mixed = new Color();
    mixed.r = lerp(color1.r, color2.r);
    mixed.g = lerp(color1.g, color2.g);
    mixed.b = lerp(color1.b, color2.b);
    return mixed;
  }
  
  this.darken = (color, factor = 0.5) => {
    const black = new Color("#000000");
    return this.mixColors(color, black, factor);
  }
  
  this.lighten = (color, factor = 0.5) => {
    const white = new Color("#ffffff");
    return this.mixColors(color, white, factor);
  }
}

class Container {
  constructor(containerData) {
    this.data = containerData;
    this.numberOfSlidesToGenerateFromWordsCache = 12;
    this.wordsCache = [];
    this.wordsCacheIndex = 0;
    this.slideCount = 0;
    this.slideIndex = 0;
    this.hasSpokenSinceTransitionEnd = true;

    WordSectionCreator.addSection(containerData);
    this.swiper = this.initializeSwiper();
    this.initializeWords();

    setInterval(() => this.speakCurrentSlideIfAllowed(), Math.max(150, swiperAnimationDuration + 11));
  }

  initializeWords() {
    Util.getWords(this.data.type, (output) => {
      this.wordsCache = eval(output);
      this.wordsCacheIndex = Math.floor(this.wordsCache.length * 0.5);
      this.hideSpinner();
      this.appendSlidesToTheLeft(this.numberOfSlidesToGenerateFromWordsCache + 1);
      this.appendSlidesToTheRight(this.numberOfSlidesToGenerateFromWordsCache);
    });
  }

  initializeSwiper() {
    const prevSlideCallbackStart = () => { this.wordsCacheIndex--; }
    const nextSlideCallbackStart = () => { this.wordsCacheIndex++; }
    const prevSlideCallbackEnd = () => { this.appendSlidesToTheLeftIfNeeded(); this.hasSpokenSinceTransitionEnd = false; }
    const nextSlideCallbackEnd = () => { this.appendSlidesToTheRightIfNeeded(); this.hasSpokenSinceTransitionEnd = false; }
    return Creator.createSwiper(this.data,
      prevSlideCallbackStart, nextSlideCallbackStart, prevSlideCallbackEnd, nextSlideCallbackEnd);
  }

  reinitializeSwiper() {
    if (this.swiper) {
      this.swiper.destroy();
      const swiperContainer = document.querySelector(Selector.swiperSelector(this.data.type));
      while (swiperContainer.firstChild)
        swiperContainer.removeChild(swiperContainer.firstChild);
      WordSectionCreator.addSwiperWrapper(swiperContainer);
    }
    this.swiper = this.initializeSwiper();
    this.appendSlidesToTheLeft(this.numberOfSlidesToGenerateFromWordsCache + 1);
    this.appendSlidesToTheRight(this.numberOfSlidesToGenerateFromWordsCache);
  }

  appendSlidesToTheLeft(numberOfSlidesToAppend, offset = 0) {
    if (this.wordsCache.length === 0) return;
    this.recalculateSlideCountAndIndex();
    const marginFromBeginning = this.slideIndex;
    const startingIndex = this.wordsCacheIndex - marginFromBeginning + offset;
    const newSlides = [];
    for (let index = 0; index < numberOfSlidesToAppend; index++) {
      newSlides.push(this.getWordByIndex(startingIndex - index));
    }
    this.swiper.prependSlide(Creator.createSlides(newSlides));
    this.recalculateSlideCountAndIndex();
  }

  appendSlidesToTheRight(numberOfSlidesToAppend, offset = 0) {
    if (this.wordsCache.length === 0) return;
    this.recalculateSlideCountAndIndex();
    const marginFromEnd = this.slideCount - this.slideIndex;
    const startingIndex = this.wordsCacheIndex + marginFromEnd + offset;
    const newSlides = [];
    for (let index = 0; index < numberOfSlidesToAppend; index++) {
      newSlides.push(this.getWordByIndex(startingIndex + index));
    }
    this.swiper.appendSlide(Creator.createSlides(newSlides));
    this.recalculateSlideCountAndIndex();
  }

  appendSlidesToTheLeftIfNeeded() {
    const marginFromEdge = 6;
    const deltaNumberOfSlides = 11;
    this.recalculateSlideCountAndIndex();
    if (this.isActiveSlideCloseToLeftEdge(marginFromEdge)) {
      this.appendSlidesToTheLeft(deltaNumberOfSlides, -1);
      this.removeSlidesFromRightEdge(deltaNumberOfSlides);
    }
  }

  appendSlidesToTheRightIfNeeded() {
    const marginFromEdge = 6;
    const deltaNumberOfSlides = 11;
    this.recalculateSlideCountAndIndex();
    if (this.isActiveSlideCloseToRightEdge(marginFromEdge)) {
      this.appendSlidesToTheRight(deltaNumberOfSlides);
      this.removeSlidesFromLeftEdge(deltaNumberOfSlides);
    }
  }

  isActiveSlideCloseToLeftEdge(marginFromEnd) {
    return this.slideIndex <= marginFromEnd;
  }

  isActiveSlideCloseToRightEdge(marginFromEnd) {
    return this.slideIndex >= this.slideCount - marginFromEnd;
  }

  removeSlidesFromLeftEdge(numberOfSlidesToRemove) {
    if (numberOfSlidesToRemove > this.slideCount) numberOfSlidesToRemove = this.slideCount;
    // To prevent an unwanted index change (Swiper issue?), remove first N-1 slides, THEN remove the first slide individually.
    // Removing all N slides makes Swiper jump to the next slide for some reason.
    if (numberOfSlidesToRemove > 1) {
      const range = (x, y) => Array.from((function* () { while (x < y) yield x++; })());
      const slidesToRemove = range(0, numberOfSlidesToRemove - 1);
      this.swiper.removeSlide(slidesToRemove);
    }
    this.swiper.removeSlide(0);
    this.recalculateSlideCountAndIndex();
  }

  removeSlidesFromRightEdge(numberOfSlidesToRemove) {
    if (numberOfSlidesToRemove > this.slideCount) numberOfSlidesToRemove = this.slideCount;
    const startingIndex = this.slideCount - numberOfSlidesToRemove;
    if (numberOfSlidesToRemove > 1) {
      const range = (x, y) => Array.from((function* () { while (x < y) yield x++; })());
      this.swiper.removeSlide(range(startingIndex, startingIndex + numberOfSlidesToRemove));
    } else {
      this.swiper.removeSlide(startingIndex);
    }
    this.recalculateSlideCountAndIndex();
  }

  recalculateSlideCountAndIndex() {
    this.slideCount = this.swiper?.slides?.length || 0;
    this.slideIndex = this.swiper?.activeIndex || 0;
  }

  getWordByIndex(index) {
    if (this.wordsCache.length === 0) return '?';
    if (index < 0)
      return this.getWordByIndex(this.wordsCache.length + index);
    if (index >= this.wordsCache.length)
      return this.getWordByIndex(index - this.wordsCache.length);
    return this.wordsCache[index] || '?';
  }

  createTextToSpeak() {
    return this.data.label + ': ' + this.getWordByIndex(this.wordsCacheIndex);
  }

  speakCurrentSlideIfAllowed() {
    if (Aria.isAdvanceAllSpeaking()) {
      this.hasSpokenSinceTransitionEnd = true;
      return;
    };
    if (this.hasSpokenSinceTransitionEnd) return;
    this.hasSpokenSinceTransitionEnd = true;
    Aria.speak(this.createTextToSpeak());
  }

  hideSpinner() {
    const overlay = document.getElementById(Selector.sectionId(this.data.type)).getElementsByClassName('section-overlay')[0];
    VisibilityController.hideElement(overlay);
    setTimeout(() => {
      overlay.style.display = 'none';
    }, spinnerOverlayFadeDuration);
  }
}

let Creator = new function() {
  this.createSwiper = (data,
    prevTransitionStartCallback, nextTransitionStartCallback,
    prevTransitionEndCallback, nextTransitionEndCallback) => {
    const prevButtonPrefix = data.prevButtonPrefix || 'Poprzednia';
    const nextButtonPrefix = data.nextButtonPrefix || 'Następna';
    const swiper = new Swiper(Selector.swiperSelector(data.type), {
      speed: swiperAnimationDuration,
      spaceBetween: 0,
      navigation: {
        prevEl: `#${Selector.sectionId(data.type)} .navigation-button-prev`,
        nextEl: `#${Selector.sectionId(data.type)} .navigation-button-next`,
      },
      a11y: {
        prevSlideMessage: `${prevButtonPrefix} ${data.label}`,
        nextSlideMessage: `${nextButtonPrefix} ${data.label}`,
      }
    });
    swiper.on('slidePrevTransitionStart', prevTransitionStartCallback);
    swiper.on('slideNextTransitionStart', nextTransitionStartCallback);
    swiper.on('slidePrevTransitionEnd', prevTransitionEndCallback);
    swiper.on('slideNextTransitionEnd', nextTransitionEndCallback);
    return swiper;
  }

  this.createElementWithClass = (tagName, className = undefined) => {
    const element = document.createElement(tagName);
    if (className) {
      element.classList.add(className);
    }
    return element;
  }

  this.createElementWithId = (tagName, id = undefined) => {
    const element = document.createElement(tagName);
    if (id) {
      element.id = id;
    }
    return element;
  }

  this.createElementWithClassAndId = (tagName, className = undefined, id = undefined) => {
    const element = this.createElementWithClass(tagName, className);
    if (id) {
      element.id = id;
    }
    return element;
  }

  this.createIcon = (svgCode, additionalClass = undefined) => {
    const iconContainer = this.createElementWithClass('div', 'icon');
    if (additionalClass) {
      iconContainer.classList.add(additionalClass);
    }
    iconContainer.innerHTML = svgCode;
    return iconContainer;
  }

  this.createSpan = (text, additionalClass = undefined) => {
    const spanElement = document.createElement('span');
    if (additionalClass) {
      spanElement.classList.add(additionalClass);
    }
    spanElement.innerHTML = text;
    return spanElement;
  }

  this.createHidingSpan = (text) => {
    const spanElement = this.createElementWithClass('span', 'hidden-when-narrow');
    spanElement.innerHTML = text;
    return spanElement;
  }

  this.createParagraph = (text, additionalClass = undefined) => {
    const paragraphElement = document.createElement('p');
    if (additionalClass) {
      paragraphElement.classList.add(additionalClass);
    }
    paragraphElement.innerHTML = text;
    return paragraphElement;
  }

  this.createLink = (text, url, additionalClass = undefined) => {
    const linkElement = document.createElement('a');
    if (additionalClass) {
      linkElement.classList.add(additionalClass);
    }
    linkElement.innerHTML = text;
    linkElement.setAttribute('href', url);
    linkElement.setAttribute('target', '_blank');
    linkElement.setAttribute('rel', 'noopener');
    return linkElement;
  }

  this.createLinkWithIcon = (text, url, svgCode, additionalClass = undefined) => {
    const iconElement = Creator.createIcon(svgCode);
    const textElement = Creator.createSpan(text);
    const link = this.createLink(iconElement.outerHTML + textElement.outerHTML, url, additionalClass);
    link.classList.add('link-with-icon');
    Creator.addRipple(link);
    return link;
  }

  this.createSlidingSheet = (id) => {
    const sheet = this.createElementWithClassAndId('div', 'sliding-sheet', id);
    const content = this.createElementWithClass('div', 'sliding-sheet-content');
    sheet.appendChild(content);
    return sheet;
  }

  this.createCircularButton = (buttonId, buttonText, svgCode, callback, preventDoubleClick = false) => {
    const button = this.createElementWithClassAndId('button', 'circular-button', buttonId);
    const callbackOnSingleClick = (e) => {
      e.preventDefault();
      callback();
    }
    if (preventDoubleClick) {
      button.addEventListener('click', Util.debounce(callbackOnSingleClick, defaultFabTransitionDuration, true));
    } else {
      button.addEventListener('click', callbackOnSingleClick);
    }

    Aria.setLabel(button, buttonText);
    button.appendChild(this.createIcon(svgCode));
    this.addRipple(button);
    return button;
  }

  this.addRipple = (parentElement) => {
    parentElement.appendChild(this.createElementWithClass('div', 'rippleJS'));
  }

  this.createSlide = (text) => {
    const capitalizedText = text?.charAt(0)?.toUpperCase() + text?.slice(1);
    const textWithNonBreakingSpace = capitalizedText.replace(/ (i|z|w|od|za|oraz) /gi, ' $1&nbsp;');
    return `<div class="swiper-slide">${textWithNonBreakingSpace}</div>`;
  }

  this.createSlides = (texts = []) => {
    let slides = [];
    for (let text of texts) {
      slides.push(this.createSlide(text));
    }
    return slides;
  }

  this.createSeparator = () => {
    const separator = document.createElement('hr');
    separator.classList.add('separator');
    return separator;
  }
}

let SpecializedCreator = new function() {
  this.createSettingsButton = () => {
    const buttonId = 'button-settings';
    const buttonText = 'Ustawienia';
    const iconSvgCode = iconCog;
    const callback = () => {
      VisibilityController.toggleSheetVisibility('settings');
    }
    const preventDoubleClick = true;
    return Creator.createCircularButton(buttonId, buttonText, iconSvgCode, callback, preventDoubleClick);
  }

  this.createAboutButton = () => {
    const buttonId = 'button-about';
    const buttonText = 'Informacje';
    const iconSvgCode = iconInfo;
    const callback = () => {
      VisibilityController.toggleSheetVisibility('about');
    }
    const preventDoubleClick = true;
    return Creator.createCircularButton(buttonId, buttonText, iconSvgCode, callback, preventDoubleClick);
  }

  this.createCheckboxIcons = () => {
    const container = Creator.createElementWithClass('div', 'checkbox-icon');
    container.appendChild(Creator.createIcon(iconCheckboxMarked, 'checked'));
    container.appendChild(Creator.createIcon(iconCheckboxBlankOutline, 'unchecked'));
    return container;
  }

  this.createAdvanceAllWordsFloatingActionButton = () => {
    const advanceAllButton = Creator.createElementWithClassAndId('button', 'floating-action-button', 'button-advance-all');
    Creator.addRipple(advanceAllButton);
    VisibilityController.showAndAllowTabbingToElement(advanceAllButton);
    Aria.setLabel(advanceAllButton, 'Kolejny zestaw słów');

    advanceAllButton.addEventListener('click', function (e) {
      e.preventDefault();

      // Block reading of individual sections, to give way to combined advance-all reading
      Aria.setIsAdvanceAllSpeaking(true);

      // Advance sections in randomized order
      const types = Object.keys(containers).map(key => containers[key].type);
      Util.shuffle(types);
      for (const [index, type] of types.entries()) {
        const swiper = Selector.getSwiper(type);
        setTimeout(() => {
          requestAnimationFrame(() => swiper?.slideNext(swiperAnimationDuration));
        }, delayBetweenLoadedWordsDuration * index);
      }

      // Prepare a combined text to speak
      setTimeout(() => {
        let textToSpeak = [];
        for (let container of containers) {
          textToSpeak.push(wordsContainer[container.type]?.createTextToSpeak());
        }
        Aria.speak(textToSpeak.join(', '));
      }, delayBetweenLoadedWordsDuration * types.length);

      // Unblock reading individual sections after a while
      setTimeout(() => {
        Aria.setIsAdvanceAllSpeaking(false);
      }, 500 + swiperAnimationDuration + delayBetweenLoadedWordsDuration * types.length)
    });

    advanceAllButton.appendChild(Creator.createIcon(iconAutoRenew));
    advanceAllButton.appendChild(Creator.createSpan('Kolejny zestaw'));
    return advanceAllButton;
  }

  this.createCloseSheetFloatingActionButton = () => {
    const closeSheetButton = Creator.createElementWithClassAndId('button', 'floating-action-button', 'button-close-sheet');
    Creator.addRipple(closeSheetButton);
    VisibilityController.hideAndPreventTabbingToElement(closeSheetButton);
    Aria.setLabel(closeSheetButton, 'Zamknij panel');

    closeSheetButton.addEventListener('click', function (e) {
      e.preventDefault();
      VisibilityController.hideSlidingSheetsAndScrim();
    });

    closeSheetButton.appendChild(Creator.createIcon(iconClose));
    closeSheetButton.appendChild(Creator.createSpan('Zamknij'));
    return closeSheetButton;
  }
}

let WordSectionCreator = new function() {
  this.addSwiperPrevNextButtons = (parentElement) => {
    const prevButton = Creator.createElementWithClass('button', 'navigation-button-prev');
    prevButton.appendChild(Creator.createIcon(iconArrowLeft));
    prevButton.style.position = 'relative';
    Creator.addRipple(prevButton);

    const nextButton = Creator.createElementWithClass('button', 'navigation-button-next');
    nextButton.appendChild(Creator.createIcon(iconArrowRight));
    nextButton.style.position = 'relative';
    Creator.addRipple(nextButton);

    parentElement.appendChild(prevButton);
    parentElement.appendChild(nextButton);
  }

  this.addSwiperWrapper = (parentElement) => {
    const swiperWrapper = Creator.createElementWithClass('div', 'swiper-wrapper');
    parentElement.appendChild(swiperWrapper);
  }

  this.addSectionHeader = (parentElement, headerText) => {
    const header = Creator.createElementWithClass('div', 'header-container');
    header.innerHTML = headerText;
    parentElement.appendChild(header);
  }

  this.addSectionOverlay = (parentElement) => {
    const overlay = Creator.createElementWithClass('div', 'section-overlay');
    VisibilityController.showElement(overlay);

    const numberOfDots = 3;
    for (let i = 0; i < numberOfDots; i++) {
      const dot = Creator.createElementWithClass('div', 'dot');
      overlay.appendChild(dot);
    }

    parentElement.appendChild(overlay);
  }

  this.addSection = (containerData) => {
    const section = Creator.createElementWithClassAndId('section', 'word-section', Selector.sectionId(containerData.type));
    this.addSectionHeader(section, containerData.label);
    this.addSectionOverlay(section);
    this.addSwiperPrevNextButtons(section);

    const swiperOuterContainer = Creator.createElementWithClass('div', 'swiper-outer-container');
    const swiperInnerContainer = Creator.createElementWithClass('div', 'swiper-container');
    this.addSwiperWrapper(swiperInnerContainer);
    swiperOuterContainer.appendChild(swiperInnerContainer);
    section.appendChild(swiperOuterContainer);

    document.getElementsByTagName('main')[0].appendChild(section);
  }
}

let SheetCreator = new function() {
  this.createSettingsSheet = () => {
    const sheetName = 'settings';
    const sheet = Creator.createSlidingSheet(sheetName);
    VisibilityController.preventTabbingToElement(sheet);

    const sheetContent = sheet.children[0];
    sheetContent.appendChild(Creator.createParagraph('Ustawienia', 'sliding-sheet-header'));

    sheetContent.appendChild(Creator.createSeparator());

    sheetContent.appendChild(Settings.createAnimationsToggle());
    sheetContent.appendChild(Settings.createCompactModeToggle());
    sheetContent.appendChild(Settings.createDarkModeToggle());

    sheetContent.appendChild(Creator.createSeparator());

    sheetContent.appendChild(Settings.createFontScaleControl());

    return sheet;
  }

  this.createAboutSheet = () => {
    const sheet = Creator.createSlidingSheet('about');
    VisibilityController.preventTabbingToElement(sheet);

    const sheetContent = sheet.children[0];

    sheetContent.appendChild(Creator.createParagraph('Magazyn Inspiracji', 'sliding-sheet-header'));

    sheetContent.appendChild(Creator.createSeparator());

    sheetContent.appendChild(Creator.createParagraph('Podręczny generator słów służących za&nbsp;punkt ' +
      'zaczepienia scenek teatru improwizowanego.', 'sliding-sheet-text'));
    sheetContent.appendChild(Creator.createParagraph('Na&nbsp;występach źródłem inspiracji jest publiczność, ' +
      'lecz&nbsp;ich pomoc nie&nbsp;jest dostępna podczas prób i&nbsp;ćwiczeń. Magazyn Inspiracji wypełnia tę&nbsp;lukę ' +
      'zbiorem ponad 1500 pomysłów, podzielonych na&nbsp;wygodne kategorie.', 'sliding-sheet-text'
    ));

    sheetContent.appendChild(Creator.createSeparator());

    sheetContent.appendChild(Creator.createParagraph('Chcesz dodać nowe słówka, pomóc w&nbsp;rozwoju aplikacji lub&nbsp;zgłosić błąd?', 'sliding-sheet-text'));
    sheetContent.appendChild(Creator.createLinkWithIcon('Repozytorium na GitHub', 'https://github.com/oczki/inspiracje', iconGithub));
    sheetContent.appendChild(Creator.createLinkWithIcon('E-mail', 'mailto:damian.oczki@gmail.com', iconEmail));

    sheetContent.appendChild(Creator.createSeparator());

    const currentYear = Math.max(2021, new Date().getFullYear());
    sheetContent.appendChild(Creator.createLinkWithIcon(`2018–${currentYear} Damian Oczki`, 'https://oczki.pl', iconCopyright));

    return sheet;
  }
}

let VisibilityController = new function() {
  this.fabAdvanceAllId = 'button-advance-all';
  this.fabCloseSheetId = 'button-close-sheet';

  this.showElement = (element) => {
    element?.classList.add(visibleClass);
  }

  this.hideElement = (element) => {
    element?.classList.remove(visibleClass);
  }

  this.preventTabbingToElement = (element) => {
    if (!element) return;
    element.style.visibility = 'hidden';
    Aria.setAttr(element, 'hidden', 'true');
  }
  
  this.allowTabbingToElement = (element) => {
    if (!element) return;
    element.style.visibility = 'initial';
    Aria.setAttr(element, 'hidden', 'false');
  }

  this.delayedPreventTabbingToElement = (element, delay) => {
    setTimeout(() => this.preventTabbingToElement(element), delay);
  }

  this.showAndAllowTabbingToElement = (element) => {
    this.showElement(element);
    this.allowTabbingToElement(element);
  }

  this.hideAndPreventTabbingToElement = (element, delay = 0) => {
    this.hideElement(element);
    this.delayedPreventTabbingToElement(element, delay);
  }

  this.getFabs = () => {
    return [
      document.getElementById(this.fabAdvanceAllId),
      document.getElementById(this.fabCloseSheetId),
    ];
  }

  this.showCloseFab = () => {
    const [fabAdvanceAll, fabCloseSheet] = this.getFabs();
    this.hideAndPreventTabbingToElement(fabAdvanceAll, fabTransitionDuration);
    this.showAndAllowTabbingToElement(fabCloseSheet);
  }

  this.showAdvanceAllFab = () => {
    const [fabAdvanceAll, fabCloseSheet] = this.getFabs();
    this.hideAndPreventTabbingToElement(fabCloseSheet, fabTransitionDuration);
    this.showAndAllowTabbingToElement(fabAdvanceAll);
  }

  this.clearFabTransformations = () => {
    const [fabAdvanceAll, fabCloseSheet] = this.getFabs();
    Util.clearTransformationProperties(fabAdvanceAll);
    Util.clearTransformationProperties(fabCloseSheet);
  }

  this.roundFabTransformations = () => {
    const [fabAdvanceAll, fabCloseSheet] = this.getFabs();
    Util.roundTransformationProperties(fabAdvanceAll);
    Util.roundTransformationProperties(fabCloseSheet);
  }

  this.delayedRoundFabTransformations = (delay = 1000) => {
    setTimeout(() => this.roundFabTransformations(), delay);
  }

  this.hideSlidingSheetsAndScrim = () => {
    const sheetsToHide = Array.from(document.querySelectorAll(`.sliding-sheet.${visibleClass}`));
    for (const sheet of sheetsToHide) {
      sheet.classList.remove(visibleClass);
      this.delayedPreventTabbingToElement(sheet, sheetClosingAnimationDuration);
    }
    Selector.getScrim()?.classList.remove(visibleClass);
    this.showAdvanceAllFab();
  }

  this.toggleSheetVisibility = (sheetId) => {
    const sheet = document.getElementById(sheetId);
    this.hideOtherSheets(sheetId);
    if (sheet?.classList.contains(visibleClass)) {
      this.showAdvanceAllFab();
      this.hideAndPreventTabbingToElement(sheet, sheetClosingAnimationDuration);
      this.hideElement(Selector.getScrim());
    } else {
      this.showCloseFab();
      this.showAndAllowTabbingToElement(sheet);
      this.showElement(Selector.getScrim());
    }
  }

  this.hideOtherSheets = (idOfSheetNotToHide) => {
    const otherSheets = Array.from(document.querySelectorAll(`.sliding-sheet:not(#${idOfSheetNotToHide})`));
    for (let otherSheet of otherSheets) {
      otherSheet.classList.remove(visibleClass);
      setTimeout(() => this.preventTabbingToElement(otherSheet), sheetClosingAnimationDuration);
    }
  }
}

let Settings = new function() {
  this.FontScale = new function() {
    this.keyName = 'font-scale';
    this.scaleDisplayElementId = 'scale-control-value';
    this.scalePlusElementId = 'button-font-scale-plus';
    this.scaleMinusElementId = 'button-font-scale-minus';

    this.getFontScale = () => {
      return localStorage.getItem(this.keyName) || 1.0;
    }

    this.setFontScale = (value) => {
      localStorage.setItem(this.keyName, value);
      document.documentElement.style.setProperty('--font-size-multiplier', value);
      this.updateCurrentScaleDisplay();
      this.updateButtonsStates();
    }

    this.increaseFontScale = () => {
      const currentFontScale = this.getFontScale();
      const upperBound = fontScaleValues[fontScaleValues.length - 1];
      const valueLargerThanCurrent = fontScaleValues.filter(value => value > currentFontScale)[0] || upperBound;
      this.setFontScale(valueLargerThanCurrent);
    }

    this.decreaseFontScale = () => {
      const currentScale = this.getFontScale();
      const lowerBound = fontScaleValues[0];
      const valueSmallerThanCurrent = Math.max(...fontScaleValues.filter(value => value < currentScale), lowerBound);
      this.setFontScale(valueSmallerThanCurrent);
    }

    this.createIncreaseFontScaleButton = () => {
      const buttonText = 'Powiększ tekst';
      const iconSvgCode = iconPlusBox;
      const callback = () => {
        this.increaseFontScale();
      }
      return Creator.createCircularButton(this.scalePlusElementId, buttonText, iconSvgCode, callback);
    }

    this.createDecreaseFontScaleButton = () => {
      const buttonText = 'Pomniejsz tekst';
      const iconSvgCode = iconMinusBox;
      const callback = () => {
        this.decreaseFontScale();
      }
      return Creator.createCircularButton(this.scaleMinusElementId, buttonText, iconSvgCode, callback);
    }

    this.createCurrentScaleDisplay = () => {
      return Creator.createElementWithId('span', this.scaleDisplayElementId);
    }

    this.updateCurrentScaleDisplay = () => {
      const scaleDisplayElement = document.getElementById(this.scaleDisplayElementId);
      if (scaleDisplayElement) {
        const valueAsPercent = `${(this.getFontScale() * 100).toFixed(0)}%`;
        scaleDisplayElement.innerHTML = valueAsPercent;
      }
    }

    this.setButtonState = (buttonId, isDisabled) => {
      const button = document.getElementById(buttonId);
      if (!button) return;
      button.disabled = isDisabled;
    }

    this.updateButtonsStates = () => {
      const currentFontScale = this.getFontScale();
      const lowerBound = fontScaleValues[0];
      const upperBound = fontScaleValues[fontScaleValues.length - 1];
      this.setButtonState(this.scaleMinusElementId, currentFontScale <= lowerBound);
      this.setButtonState(this.scalePlusElementId, currentFontScale >= upperBound);
    }

    this.createControl = () => {
      const container = Creator.createElementWithId('div', 'scale-control-container');
      container.appendChild(Creator.createIcon(iconFormatSize, 'decorative-icon'));
      container.appendChild(Creator.createSpan('Skala'));
      container.appendChild(this.createDecreaseFontScaleButton());
      container.appendChild(this.createCurrentScaleDisplay());
      container.appendChild(this.createIncreaseFontScaleButton());

      this.setFontScale(this.getFontScale());

      return container;
    }
  };

  this.AnimationsToggle = new function() {
    this.keyName = 'animations-disabled';

    this.doesTheUserPreferReducedMotion = () => {
      return window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    }

    this.shouldAnimationsToggleBeChecked = () => {
      const currentAnimationsDisabledKeyValue = localStorage.getItem(this.keyName);
      if (currentAnimationsDisabledKeyValue === null)
        return !this.doesTheUserPreferReducedMotion();
      else
        return currentAnimationsDisabledKeyValue === 'false';
    }

    this.setAnimationsDisabledBodyClass = (state) => {
      document.body.classList.toggle('no-animations', state);
    }

    this.setAnimationsDisabledState = (state) => {
      localStorage.setItem(this.keyName, state);
      this.setAnimationsDisabledBodyClass(state);
      if (state) {
        swiperAnimationDuration = 0;
        sheetClosingAnimationDuration = 0;
        delayBetweenLoadedWordsDuration = 0;
        fabTransitionDuration = 0;
        spinnerOverlayFadeDuration = 0;
      } else {
        swiperAnimationDuration = defaulSwiperAnimationDuration;
        sheetClosingAnimationDuration = defaultSheetClosingAnimationDuration;
        delayBetweenLoadedWordsDuration = defaultDelayBetweenLoadedWordsDuration;
        fabTransitionDuration = defaultFabTransitionDuration;
        spinnerOverlayFadeDuration = defaultSpinnerOverlayFadeDuration;
      }
    }

    this.createToggle = () => {
      const toggle = Creator.createElementWithId('input', `${this.keyName}-checkbox`);
      toggle.type = 'checkbox';
      toggle.checked = this.shouldAnimationsToggleBeChecked(this.keyName);
      this.setAnimationsDisabledState(!toggle.checked);
      toggle.addEventListener('change', (event) => {
        this.setAnimationsDisabledState(!event.currentTarget.checked);
        this.reinitializeAllSwipers();
      });
      const labelElement = Creator.createElementWithClassAndId('label', 'checkbox-label', this.keyName);
      labelElement.appendChild(toggle);
      labelElement.appendChild(SpecializedCreator.createCheckboxIcons());
      labelElement.appendChild(Creator.createSpan('Animacje'));
      Creator.addRipple(labelElement);
      return labelElement;
    }

    this.reinitializeAllSwipers = () => {
      for (const containerData of containers) {
        wordsContainer[containerData.type].reinitializeSwiper();
        new ColorSetter(containerData).setColors();
      }
    }
  };

  this.CompactModeToggle = new function() {
    this.keyName = 'compact-mode';

    this.shouldToggleBeChecked = () => {
      return localStorage.getItem(this.keyName) === 'true';
    }

    this.setCompactModeState = (state) => {
      localStorage.setItem(this.keyName, state);
      document.body.classList.toggle('compact', state);
    }

    this.createToggle = () => {
      const toggle = Creator.createElementWithId('input', `${this.keyName}-checkbox`);
      toggle.type = 'checkbox';
      toggle.checked = this.shouldToggleBeChecked();
      this.setCompactModeState(toggle.checked);
      toggle.addEventListener('change', (event) => {
        this.setCompactModeState(event.currentTarget.checked);
      });

      const labelElement = Creator.createElementWithClassAndId('label', 'checkbox-label', this.keyName);
      labelElement.appendChild(toggle);
      labelElement.appendChild(SpecializedCreator.createCheckboxIcons());
      labelElement.appendChild(Creator.createSpan('Tryb kompaktowy'));
      Creator.addRipple(labelElement);
      return labelElement;
    }
  };

  this.DarkModeToggle = new function() {
    this.keyName = 'dark-mode';

    this.doesTheUserPreferDarkMode = () => {
      return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    }

    this.shouldToggleBeChecked = () => {
      const currentDarkModeKeyValue = localStorage.getItem(this.keyName);
      if (currentDarkModeKeyValue === null)
        return this.doesTheUserPreferDarkMode();
      else
        return currentDarkModeKeyValue === 'true';
    }

    this.setDarkModeState = (state) => {
      localStorage.setItem(this.keyName, state);
      document.body.classList.toggle('dark', state);
      isDarkModeEnabled = state;
      Settings.updateColors();
      requestAnimationFrame(() => {
        const bgColor = window.getComputedStyle(document.body).backgroundColor;
        document.querySelector('meta[name="theme-color"]')?.setAttribute('content', bgColor);
      });
    }

    this.createToggle = () => {
      const toggle = Creator.createElementWithId('input', `${this.keyName}-checkbox`);
      toggle.type = 'checkbox';
      toggle.checked = this.shouldToggleBeChecked();
      this.setDarkModeState(toggle.checked);
      toggle.addEventListener('change', (event) => {
        this.setDarkModeState(event.currentTarget.checked);
      });

      const labelElement = Creator.createElementWithClassAndId('label', 'checkbox-label', this.keyName);
      labelElement.appendChild(toggle);
      labelElement.appendChild(SpecializedCreator.createCheckboxIcons());
      labelElement.appendChild(Creator.createSpan('Tryb ciemny'));
      Creator.addRipple(labelElement);
      return labelElement;
    }
  };

  this.updateFontScaleElements = () => {
    this.FontScale.updateCurrentScaleDisplay();
    this.FontScale.updateButtonsStates();
  }

  this.updateColors = () => {
    for (let container of containers) {
      new ColorSetter(container).setColors();
    }
  }

  this.disableAnimationsDuringResize = () => {
    this.AnimationsToggle.setAnimationsDisabledBodyClass(true);
  }

  this.enableAnimationsAfterResize = () => {
    if (this.AnimationsToggle.shouldAnimationsToggleBeChecked()) {
      this.AnimationsToggle.setAnimationsDisabledBodyClass(false);
    }
  }

  this.createFontScaleControl = () => {
    return this.FontScale.createControl();
  }

  this.createAnimationsToggle = () => {
    return this.AnimationsToggle.createToggle();
  }

  this.createCompactModeToggle = () => {
    return this.CompactModeToggle.createToggle();
  }

  this.createDarkModeToggle = () => {
    return this.DarkModeToggle.createToggle();
  }
}

let ElementPopulator = new function() {
  this.populateSlidingSheetsContainer = () => {
    const container = document.getElementById('sliding-sheets-container');
    container.appendChild(SheetCreator.createSettingsSheet());
    container.appendChild(SheetCreator.createAboutSheet());
  }

  this.populateFooter = () => {
    const footer = document.getElementsByTagName('footer')[0];

    const innerContainer = Creator.createElementWithId('div', 'footer-inner-container');
    innerContainer.appendChild(SpecializedCreator.createAdvanceAllWordsFloatingActionButton());
    innerContainer.appendChild(SpecializedCreator.createCloseSheetFloatingActionButton());
    innerContainer.appendChild(SpecializedCreator.createSettingsButton());
    innerContainer.appendChild(SpecializedCreator.createAboutButton());

    footer.appendChild(innerContainer);
    VisibilityController.showElement(footer);
  }

  this.populatePageWithWordContainers = () => {
    for (const container of containers) {
      wordsContainer[container.type] = new Container(container);
    }
  }
}

let GlobalEventHandler = new function() {
  this.attachEventsToSheetsAndScrim = () => {
    Selector.getScrim()?.addEventListener('click', (event) => {
      event.preventDefault();
      VisibilityController.hideSlidingSheetsAndScrim();
    });

    window.addEventListener('keydown', (event) => {
      if (event.keyCode === 27) {
        VisibilityController.hideSlidingSheetsAndScrim();
      }
    });
  }

  this.attachClickEventToAdvanceAllFabToRotateIcon = () => {
    const advanceAllButton = document.getElementById('button-advance-all');
    const callbackFabClicked = (e) => {
      e.preventDefault();

      // Start animating the icon
      advanceAllButton.classList.add('rotate');

      // Stop animating the icon after a while
      setTimeout(() => {
        advanceAllButton.classList.remove('rotate');
      }, iconRotationDuration);
    }

    advanceAllButton.addEventListener('click', Util.throttle(callbackFabClicked, defaultIconRotationDuration));
  }

  this.handleKeyboardInput = (event) => {
    if (event.keyCode === 9) {
      document.body.classList.add('show-outline');
      window.removeEventListener('keydown', GlobalEventHandler.handleKeyboardInput);
      window.addEventListener('mousedown', GlobalEventHandler.handleMouseInput);
    }
  }

  this.handleMouseInput = () => {
    document.body.classList.remove('show-outline');
    window.addEventListener('keydown', GlobalEventHandler.handleKeyboardInput);
    window.removeEventListener('mousedown', GlobalEventHandler.handleMouseInput);
  }

  this.handleFirstKeyboardInput = () => {
    window.addEventListener('keydown', GlobalEventHandler.handleKeyboardInput);
  }

  this.handleWindowResize = () => {
    const delayBetweenFunctionCalls = 100;
    const callbackResizeStart = () => {
      Settings.disableAnimationsDuringResize();
      VisibilityController.clearFabTransformations();
    };
    const callbackResizeEnd = () => {
      Settings.enableAnimationsAfterResize();
      VisibilityController.roundFabTransformations();
    };
    window.addEventListener('resize', Util.debounce(callbackResizeStart, delayBetweenFunctionCalls, true));
    window.addEventListener('resize', Util.debounce(callbackResizeEnd, delayBetweenFunctionCalls));
  }
}

let Aria = new function() {
  this.isAdvanceAllSpeakingFlag = false;

  this.setAttr = (element, ariaAttribute, value) => {
    element.setAttribute(`aria-${ariaAttribute}`, value);
  }

  this.setLabel = (element, value) => {
    this.setAttr(element, 'label', value);
  }

  this.speak = (text) => {
    const id = 'speak-' + Date.now();
    const ghostElement = Creator.createElementWithClassAndId('div', 'aria-only', id);
    this.setAttr(ghostElement, 'live', 'assertive');
    document.body.appendChild(ghostElement);

    setTimeout(() => {
      document.getElementById(id).innerHTML = text;
    }, 500);
    setTimeout(() => {
      document.body.removeChild(document.getElementById(id));
    }, 1000);
  }

  this.isAdvanceAllSpeaking = () => {
    return this.isAdvanceAllSpeakingFlag;
  }

  this.setIsAdvanceAllSpeaking = (newValue) => {
    this.isAdvanceAllSpeakingFlag = newValue;
  }
}

function init() {
  ElementPopulator.populateSlidingSheetsContainer();
  GlobalEventHandler.attachEventsToSheetsAndScrim();
  GlobalEventHandler.handleFirstKeyboardInput();
  ElementPopulator.populateFooter();
  ElementPopulator.populatePageWithWordContainers();
  Settings.updateColors();
  Settings.updateFontScaleElements();
  GlobalEventHandler.handleWindowResize();
  GlobalEventHandler.attachClickEventToAdvanceAllFabToRotateIcon();
  VisibilityController.delayedRoundFabTransformations();
}

if (document.readyState != 'loading')
  init();
else if (document.addEventListener)
  document.addEventListener('DOMContentLoaded', init);
else
  document.attachEvent('onreadystatechange', function () {
    if (document.readyState == 'complete')
      init();
  });